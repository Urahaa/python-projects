# -*- coding: utf-8 -*-
"""genetico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I7OQBAMd6YibCe9_1E-nliBtJT1CpxqL

Setup
- Criar peso das cidades [OK]
- Criar mapa de cidades aleatórias [OK]

Iteração
- Aplicar a função fitness [OK]
- Ordenar os individuos por menor custo e pegar os 10 com menor custo [OK]
- Aplicar a probabilidade e escolher dois individuos (Roleta) [OK]
- Aplicar o crossover nos individuos escolhidos (Cycle) [OK]
- Aplicar a mutação no filho gerado pelo crossover [OK]

Plotar gráficos [OK]
"""

import random
import numpy as np
from numpy.random import choice
import operator
import math

#Inicialização das variavéis
pesoCidade = {}
contGeracao = 0
nGeracao = 10000
nCidades = 20
nPop = 20
numMaxAmostras = 10

#Gera um valor aleatório entre 0,0 até 1,1 e popula um mapa onde a chave é o número da cidade
def randomizaPesoCidade(nCidades):
    for x in range(1, nCidades+1):
      pesoCidade[x] = (random.random(), random.random())

#Gera um mapa de chave e valor, onde a chave é o individuo e o valor é uma lista gerada aleatoriamente com valores não repetidos de 1 a 20
def makePopulacao(npop):
    for x in range(npop):
        mapaPopulacao[x] = list(range(1,21))
        random.shuffle(mapaPopulacao[x])

#Aplica o fitness entre duas cidades usando o peso que foi gerado anteriormente 
def fitness(cidade1, cidade2):
  return math.sqrt(((pesoCidade[cidade1][0] - pesoCidade[cidade2][0])**2) + ((pesoCidade[cidade1][0] - pesoCidade[cidade2][0])**2))

#Dado cada individuo dentro do mapa da população, é realizado o cálculo do fitness entre cada elemento da lista de cidades
def calcularFitness():
  mapaFitness = {}
  for x in mapaPopulacao:
    caminhos = mapaPopulacao[x]
    totalFitness = 0
    for i in range(len(caminhos)-1):
      if i == len(caminhos)-1:
        #É necessário realizar o cálculo do último elemento com o primeiro elemento da lista
        totalFitness += fitness(caminhos[i], caminhos[0])
      else:
        #Seleciona o elemento i do caminho do individuo e seu sucessor
        totalFitness += fitness(caminhos[i], caminhos[i+1])
    mapaFitness[x] = totalFitness
  return mapaFitness

#Inicia um array com probabilidades, onde o primeiro elemento tem a menor probabilidade de ser escolhido
def roleta(mapaFitness):
  probabilidades = [1,2,3,4,5,6,7,8,9,10]
  probabilidades = np.array(probabilidades)
  #Utilizado para normalização dos valores
  probabilidades = probabilidades / np.sum(probabilidades)
  #Escolhe um elemento do mapa, dado a probabilidade de cada individuo
  return choice(mapaFitness, 1, p=probabilidades)[0]

#A partir de dois individuos selecionados na roleta, realiza o crossover entre eles 
def realizarRoleta(mapaFitness):
  individuo_x = roleta(mapaFitness)
  individuo_y = roleta(mapaFitness)
  return realizarCrossover(individuo_x, individuo_y)

#Para o crossover é randomizado uma sequência de 0 ou 1 para cada cidade
def randomizaSequencia():
    sequence = []
    for i in range(nCidades):
      sequence.append(random.randint(0, 1))
    return sequence

#Aplica o crossover entre dois individuos, assim gerando um novo individuo
def realizarCrossover(x, y):
  #Inicializa o array de sequências
  sequence = randomizaSequencia()
  #Seleciona os respectivos individuos da roleta do mapa de população
  escolhido_x = mapaPopulacao.get(x)
  escolhido_y = mapaPopulacao.get(y)
  novo_individuo = []
  for i in range(nCidades):
    #Para cada posição da sequência que for '1' significa que irá manter a cidade do individuo_x na mesma posição
    if sequence[i] == 1:
      novo_individuo.append(escolhido_x[i])
    #Caso não seja, é colocado 0 nessa posição para ser tratado depois  
    else:
       novo_individuo.append(0)

  #Para evitar duplicidades, definimos um array com todos os caminhos que não estão inclusos no novo individuo
  caminhos_faltantes = list(filter(lambda caminho: caminho not in novo_individuo, escolhido_y))
  for i in range(nCidades):
    #Quando determinada posição for 0, será incluso o caminho do individuo_y, mantendo a mesma ordem original
    if novo_individuo[i] == 0:
      novo_individuo[i] = caminhos_faltantes.pop(0)
  return novo_individuo

import matplotlib.pyplot as plt

def showGeneration(mapaFit, mapaFitPlot):
  print("Melhor solucao:", list(mapaPopulacao.values())[0])
  print("Melhor custo:", list(mapaFit.values())[0])
  print("Número de cidades: 20")
  plt.title("Melhores custos nas gerações")
  plt.plot(list(mapaFitPlot.keys()), list(mapaFitPlot.values()))
  plt.ylabel('Fitness')
  plt.xlabel('Iteracao')
  plt.show()

def showCoords(melhorCaminho):
  x_list = []
  y_list = []
  for c in melhorCaminho:
      x_list.append(pesoCidade[c][0])
      y_list.append(pesoCidade[c][1])
  plt.title("Melhor caminho") 
  plt.scatter(x_list, y_list)
  plt.ylabel('Coord Y')
  plt.xlabel('Coord X')
  plt.show()

mapaPopulacao = {}

#Realiza o tratamento da população, removendo os individuos com maior peso
def tratarMapaPopulacao(mapaFitness):
  for i in list(mapaPopulacao.keys()):
    if i not in list(mapaFitness.keys()):
      del mapaPopulacao[i]

#Realiza a mutação de um individuo, trocando a posição entre duas cidades
def realizarMutacao(novo_individuo):
  pos_x = random.randint(0, 19)
  pos_y = random.randint(0, 19)
  mutX = novo_individuo[pos_x]
  mutY = novo_individuo[pos_y]
  novo_individuo[pos_x] = mutY
  novo_individuo[pos_y] = mutX
  return novo_individuo

#Função responsável para funcionar o algoritmo, inicializa as iterações das gerações
def iniciaGeracao():
  nGeracaoIndv = 21
  mapaFitness = {}
  mapaFitnessPlot = {}
  count = 1
  for i in range(nGeracao):
    #Inicializa o mapa de fitness, onde a chave é o individuo e o valor é o peso calculado da aplicação do fitness 
    mapaFitness = calcularFitness()
    #Ordena o mapa do menor para o maior peso dos caminhos
    mapaFitness = sorted(mapaFitness.items(), key=operator.itemgetter(1))
    #Mantem apenas os 10 melhores individuos
    mapaFitness =  dict(mapaFitness[:numMaxAmostras])
    #Trata a populacao
    tratarMapaPopulacao(mapaFitness)
    #Completamos os individuos faltantes com a geração de novos indivudos a partir do crossover
    for i in range(numMaxAmostras):
      novo_individuo = realizarRoleta(list(mapaFitness.keys()))
      #Para cada novo individuo é aplicado a mutação
      novo_individuo = realizarMutacao(novo_individuo)
      mapaPopulacao[nGeracaoIndv] = novo_individuo
      nGeracaoIndv += 1
    #É feito o calculo e a ordenação novamente, apenas para exibição dos valores considerando os novos individuos gerados
    mapaFitness = calcularFitness()
    mapaFitness = sorted(mapaFitness.items(), key=operator.itemgetter(1))
    mapaFitness =  dict(mapaFitness)
    mapaFitnessPlot[count] = list(mapaFitness.values())[0]
    count+=1
  print("Total população gerada: ", nGeracaoIndv)
  print("Total população atual: ", len(mapaPopulacao))
  showGeneration(mapaFitness, mapaFitnessPlot)
  showCoords(list(mapaPopulacao.values())[0])
    
randomizaPesoCidade(nCidades)
makePopulacao(nPop)
iniciaGeracao()